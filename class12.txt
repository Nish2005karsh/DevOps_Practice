Kubernetes
Configuration management tools like ansible and chef
Why before docker ?

Before Docker existed (pre-2013), developers and operations teams had a huge pain point:
“It works on my machine!”
You’d write an app in Node.js 18, but your teammate had Node.js 16 — and the app wouldn’t run.
Production servers might have different libraries, OS versions, or dependencies.
Setting up environments for each project took hours (installing Python, MySQL, Redis, etc.).
Scaling apps meant manually configuring servers and copying code.

So the world needed a standard, portable environment where:
You can package your app and everything it needs.
You can run it anywhere — laptop, server, or cloud — with identical behavior.
The Solution → Docker

Docker has 2 parts called as image and container
Docker->A container is like a mini computer that includes apps dependencies +runtime
Docker image->Blue print of that container
Docker containers are a running instance of docker images

Docker = A universal shipping container for software.
Core Uses of Docker:

Consistency — same environment everywhere.
Portability — run on any machine or cloud.
Isolation — each app has its own sandbox.
Scalability — spin up multiple containers easily.
CI/CD Integration — automate builds & tests easily.

Why was Kubernetes created?
The Problem(after docker):
Docker solved the packaging issue — but a new one appeared:
Now I have hundreds of containers... who manages them?

For example:
You have 50 microservices (frontend, backend, database, cache, etc.).
Each runs in its own Docker container.
You need to deploy them on 10 machines.
You must restart containers if they crash.
You want to update apps with zero downtime.
You want to automatically scale based on traffic.

Doing this manually is a nightmare
You’d need something to orchestrate all those containers.

Solution ->Kubernetes
Created by Google (open-sourced in 2014), Kubernetes was built to manage, schedule, and scale containers automatically.

Core Uses of Kubernetes:

Orchestration — Manages where containers run and how many.

Scaling — Automatically adds/removes containers based on load.

Self-Healing — Restarts failed containers automatically.

Load Balancing — Distributes traffic between containers.

Rolling Updates — Updates apps without downtime.

Multi-cloud flexibility — Works across AWS, GCP, Azure, or on-prem servers

How they work together
Layer	Tool	Purpose
Application Code	Node.js / Python / etc.	Your logic
Containerization	Docker	Packages your app & dependencies
Orchestration	Kubernetes	Manages and scales those containers
Infrastructure	AWS / GCP / Azure	Provides the servers to run everything

Docker makes apps portable.
Kubernetes makes portable apps scalable and manageable.

VM->one app on one VM not cool so docker came 
To manage those 100's containers->We use Kubernetes
Kubernetes is used to manage microservices
its much more than just an orchastrator


orchatestors->help in managing and deploying app dynamically

Cloud native applications
Cloud-native applications are apps specifically designed and built to run on the cloud — not just “moved” to it.
They are built to take full advantages of cloud technologies:
Auto-scaling

Load balancing

Container orchestration (Kubernetes)

Managed services (Databases, Queues, etc.)

Difference between  Monolithic and Microlithic Architecture
Monolithic->Single large unit all features like backend databse logic etc 
Microlithic->A microservices app is split into independent small services, each responsible for one specific feature.
Each service runs in its own process and communicates via APIs (usually HTTP/REST or gRPC).

AWS offers cloud computing
OpenStack ->Open source alternative for AWS
Google created Kubernetes 
