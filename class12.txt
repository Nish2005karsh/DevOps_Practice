Kubernetes
Configuration management tools like ansible and chef
Why before docker ?

Before Docker existed (pre-2013), developers and operations teams had a huge pain point:
â€œIt works on my machine!â€
Youâ€™d write an app in Node.js 18, but your teammate had Node.js 16 â€” and the app wouldnâ€™t run.
Production servers might have different libraries, OS versions, or dependencies.
Setting up environments for each project took hours (installing Python, MySQL, Redis, etc.).
Scaling apps meant manually configuring servers and copying code.

So the world needed a standard, portable environment where:
You can package your app and everything it needs.
You can run it anywhere â€” laptop, server, or cloud â€” with identical behavior.
The Solution â†’ Docker

Docker has 2 parts called as image and container
Docker->A container is like a mini computer that includes apps dependencies +runtime
Docker image->Blue print of that container
Docker containers are a running instance of docker images

Docker = A universal shipping container for software.
Core Uses of Docker:

Consistency â€” same environment everywhere.
Portability â€” run on any machine or cloud.
Isolation â€” each app has its own sandbox.
Scalability â€” spin up multiple containers easily.
CI/CD Integration â€” automate builds & tests easily.

Why was Kubernetes created?
The Problem(after docker):
Docker solved the packaging issue â€” but a new one appeared:
Now I have hundreds of containers... who manages them?

For example:
You have 50 microservices (frontend, backend, database, cache, etc.).
Each runs in its own Docker container.
You need to deploy them on 10 machines.
You must restart containers if they crash.
You want to update apps with zero downtime.
You want to automatically scale based on traffic.

Doing this manually is a nightmare
Youâ€™d need something to orchestrate all those containers.

Solution ->Kubernetes
Created by Google (open-sourced in 2014), Kubernetes was built to manage, schedule, and scale containers automatically.

Core Uses of Kubernetes:

Orchestration â€” Manages where containers run and how many.

Scaling â€” Automatically adds/removes containers based on load.

Self-Healing â€” Restarts failed containers automatically.

Load Balancing â€” Distributes traffic between containers.

Rolling Updates â€” Updates apps without downtime.

Multi-cloud flexibility â€” Works across AWS, GCP, Azure, or on-prem servers

How they work together
Layer	Tool	Purpose
Application Code	Node.js / Python / etc.	Your logic
Containerization	Docker	Packages your app & dependencies
Orchestration	Kubernetes	Manages and scales those containers
Infrastructure	AWS / GCP / Azure	Provides the servers to run everything

Docker makes apps portable.
Kubernetes makes portable apps scalable and manageable.

VM->one app on one VM not cool so docker came 
To manage those 100's containers->We use Kubernetes
Kubernetes is used to manage microservices
its much more than just an orchastrator


orchatestors->help in managing and deploying app dynamically

Cloud native applications
Cloud-native applications are apps specifically designed and built to run on the cloud â€” not just â€œmovedâ€ to it.
They are built to take full advantages of cloud technologies:
Auto-scaling

Load balancing

Container orchestration (Kubernetes)

Managed services (Databases, Queues, etc.)

Difference between  Monolithic and Microlithic Architecture
Monolithic->Single large unit all features like backend databse logic etc 
Microlithic->A microservices app is split into independent small services, each responsible for one specific feature.
Each service runs in its own process and communicates via APIs (usually HTTP/REST or gRPC).

AWS offers cloud computing
OpenStack ->Open source alternative for AWS
Google created Kubernetes 

Docker->Cri(Container Runtime Interface)
Kubernetes->Orchestrator

Kubernetes cluster->Bunch of worker  nodes+control plane(master node)
node->Virtual machine 
Kubectl is a cli tools connects with control plane
declarative->Writing yaml(manifest)
imperiative ways

Kubernetes help in container management
yt.com->container->people
pod is  a scheduling unit
P1->Create microservices
P2->Containerize
P3->CONtainer in Pods
P4->deploy the Pods
Controller are loops 5 pods->controller
Deployment is a built in controller
control plane
POST API YAML FILES CREATE PODS  MANIFEST FILES
Monokle->ðŸ§° Monokle is an open-source YAML & Kubernetes configuration management tool.

Controller manager->DS,CS(CURRENT STATE),DIFF,CHANGES
ETCD
Worker node has kube proxy,kublet and container runtime
kublet->api server listen

Kubernetes Installation
Install kubectl on windows

Tools to use monokel,lens,kubescape,datree,teleport and civio

